
name_map = {"Penn": "Pennsylvania",
            "UMBC": "Maryland-Baltimore County",
            "UNC": "North Carolina",
            "UCSB": "UC Santa Barbara",
            "USC": "Southern California",
            "VCU": "Virginia Commonwealth",
            "LSU": "Louisiana State",
            "BYU": "Brigham Young",
            "UConn": "Connecticut",
            "Ole Miss": "Mississippi",
            "UC-Irvine": "UC Irvine",
            "Saint Mary's": "Saint Mary's (CA)",
            "UCF": "Central Florida",
            "UC-Davis": "UC Davis",
            "ETSU": "East Tennessee State",
            "SMU": "Southern Methodist"}

def score_tournament(rounds_predict, rounds_truth, debug=False):
    # each round has 32 points available
    total = 0
    for r_predict, r_truth in zip(rounds_predict, rounds_truth):
        points_per_game = 32 // len(r_predict)
        subtotal_round = 0
        for g_predict, g_truth in zip(r_predict, r_truth):
            if g_predict[g_predict[2]][1] == g_truth[g_truth[2]][1]:
                subtotal_round += points_per_game
        if debug:
            print("Round of {} Subtotal: {}".format(2*len(r_predict), subtotal_round))
            
        total += subtotal_round
        
    if debug:
        print("Total Points: {}".format(total))
    
    return total
            

def print_tournament(rounds):
    for r in rounds:
        print("======== Round of {} ==========".format(2*len(r)))
        for g in r:
            print(g)
            
def get_initial_matchups(rounds):
    # input: list of rounds as generated by parse_tournament
    # output: list of ((rankA, teamA), (rankB, teamB)) for round of 64
    return [((a[0], a[1]), (b[0], b[1])) for a, b, _, _ in rounds[0]]


def simulate_tournament(stats_df, matchups64, score_fun, debug=False):
    # input list of ((rankA, teamA), (rankB, teamB)) pairs
    # returns list of rounds, list of games, where game is ((rankA, teamA), (rankB, teamB), winner)
    N = 64
    matchups = matchups64
    rounds = []
    
    while True:
        if debug:
            print("=====Round of {}=====".format(N))
            
        results = simulate_round(stats_df, matchups, score_fun, debug)
        rounds.append(results)
        
        N = N // 2
        
        if N > 1:
            matchups = next_round_matchups(results)
        else:
            break
            
    return rounds
    
    
def simulate_round(stats_df, matchups, score_fun, debug=False):
    # input list of ((rankA, teamA), (rankB, teamB)) pairs for round
    # return list of ((rankA, teamA), (rankB, teamB), winner) for round
    results = []
    
    for a, b in matchups:
        teamA = name_map[a[1]] if a[1] in name_map else a[1]
        teamB = name_map[b[1]] if b[1] in name_map else b[1]
        
        winner = simulate_game(stats_df, teamA, teamB, score_fun, debug=False)
        
        if debug:
            print("{} vs {}: {}".format(teamA, teamB, winner))
            
        results.append((a, b, winner))
    
    return results    
        
    
def next_round_matchups(results):
    # input list of ((rankA, teamA), (rankB, teamB), winner) for round
    # return list of ((rankA, teamA), (rankB, teamB)) for next round
    matchups = []
    
    for i in range(0, len(results), 2):
        upper = results[i][results[i][2]]
        lower = results[i+1][results[i+1][2]]
        
        matchups.append((upper, lower))
        
    return matchups


# return 0 if teamA wins, 1 if teamB wins
def simulate_game(stats_df, teamA, teamB, score_fun, debug=False):
    if debug:
        print("TeamA: {}, TeamB: {}".format(teamA, teamB))
        
    return score_fun(stats_df.loc[teamA], stats_df.loc[teamB], debug)
